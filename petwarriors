local Library = loadstring(game:HttpGet("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/Pet-Warriors/refs/heads/main/test"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()


local Window = Library:Window{
    Title = "Pet Warriors - Mining",
    SubTitle = "Script Hub",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Resize = false,
    Acrylic = true,
    Theme = "Vynixu",
    MinimizeKey = Enum.KeyCode.LeftShift
}


local Tabs = {
    Mining = Window:AddTab({ Title = "Mining", Icon = "pickaxe" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
}


-- Services and Controllers (defined once)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Function to click top-right
local function clickTopRight()
    local screenSize = workspace.CurrentCamera.ViewportSize
    local x = screenSize.X - 5  -- slightly inside from the right edge
    local y = 5                 -- slightly down from the top

    -- Mouse down + mouse up
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)

    print("[AutoClick] Clicked at top-right:", x, y)
end


local teleport = Tabs.Mining:AddSection("Teleport")

local autoTeleportEnabled = false
local autoTeleportTask = nil

teleport:AddToggle("AutoTeleport", {
    Title = "Auto Teleport",
    Description = "Teleports you to the mining area if you're not currently in it. Use this if you have auto load (found in settings).",
    Default = false,
    Callback = function(value)
        autoTeleportEnabled = value

        if value then
            autoTeleportTask = task.spawn(function()
                while autoTeleportEnabled do
                    local throneExists = false
                    local success, err = pcall(function()
                        local pyramidInside = workspace:FindFirstChild("PyramidInside")
                        if pyramidInside then
                            local throne = pyramidInside:FindFirstChild("CleopatraThrone")
                            if throne then
                                throneExists = true
                            end
                        end
                    end)

                    if not throneExists then
                        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            hrp.CFrame = CFrame.new(
                                7639.73877, 197.489105, -1442.22095,
                                1, -5.37404343e-09, 3.2594231e-14,
                                5.37404343e-09, 1, -3.94641013e-08,
                                -3.23821475e-14, 3.94641013e-08, 1
                            )
                        end
                    end
                    task.wait(3)
                end
            end)
        else
            if autoTeleportTask then
                task.cancel(autoTeleportTask)
                autoTeleportTask = nil
            end
        end
    end
})

local selectblock = Tabs.Mining:AddSection("Auto Mine")

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
local RunService = game:GetService("RunService")
local BlocksEnum = require(ReplicatedStorage.Shared.Enums.Minigames.Blocks)
local MinesData = require(ReplicatedStorage.Shared.Balancing.Shared.Minigames.Mines.Mines)


-- Wait for Knit to initialize
if not Knit.IsStarted then
    Knit.OnStart():await()
end


local MiningSiteController = Knit.GetController("MiningSiteController")
local BlocksDefinition = require(ReplicatedStorage.Shared.Balancing.Shared.Minigames.Mines.Blocks)
local MiningSiteRemote = ReplicatedStorage.Shared.Packages.Knit.Services.MiningSiteService.RE.Hit


-- Build mapping: MaxHealth -> Block Name
local maxHealthToBlockName = {}
for _, blockData in pairs(BlocksDefinition) do
    if blockData.Health and blockData.Name then
        maxHealthToBlockName[blockData.Health] = blockData.Name
    end
end


-- Build block list for dropdown
local blockNames = {}
for _, blockData in pairs(BlocksDefinition) do
    if blockData.Name ~= "Air" and blockData.Name ~= "Indestructible" then
        table.insert(blockNames, blockData.Name)
    end
end
table.sort(blockNames)


-- Block priorities
local blockPriorities = {}
local nextPriority = 1


-- Priority paragraph
local blockPriorityParagraph = selectblock:AddParagraph("MinePriority", {
    Title = "Mining Priority",
    Content = "No blocks selected",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})


local function updateBlockPriorityDisplay()
    local prioritized = {}
    for name, priority in pairs(blockPriorities) do
        table.insert(prioritized, {name = name, priority = priority})
    end
    table.sort(prioritized, function(a,b) return a.priority < b.priority end)


    if #prioritized == 0 then
        blockPriorityParagraph:SetValue("No blocks selected")
        return
    end


    local text = "Priority order:\n"
    for i, item in ipairs(prioritized) do
        text = text .. i .. ". " .. item.name .. "\n"
    end
    blockPriorityParagraph:SetValue(text)
end


-- Dropdown for block selection
selectblock:AddDropdown("BlockSelect", {
    Title = "Select Blocks to Mine",
    Description = "Blocks will be prioritized in the order you select them. First selected = highest priority.",
    Values = blockNames,
    Multi = true,
    Searchable = true,
    Default = {},
    Callback = function(value)
        local currentlySelected = {}
        for name, selected in pairs(value) do
            if selected then currentlySelected[name] = true end
        end


        -- Remove deselected blocks
        for name in pairs(blockPriorities) do
            if not currentlySelected[name] then
                blockPriorities[name] = nil
            end
        end


        -- Add newly selected blocks with incrementing priority
        for name, selected in pairs(value) do
            if selected and not blockPriorities[name] then
                blockPriorities[name] = nextPriority
                nextPriority = nextPriority + 1
            end
        end


        updateBlockPriorityDisplay()
    end
})


-- BlockId <-> Name mapping for readability
local BlockIdToName = {}
for name, id in pairs(BlocksEnum) do
    BlockIdToName[id] = name
end


-- Table to store min/max Y for each blockId
local BlockYRanges = {}
for _, areaData in pairs(MinesData) do
    if areaData.Layers then
        for _, layer in ipairs(areaData.Layers) do
            if layer.LootPlan and layer.LootPlan.Rewards then
                for blockId in pairs(layer.LootPlan.Rewards) do
                    if not BlockYRanges[blockId] then
                        BlockYRanges[blockId] = {MinY = layer.MinY, MaxY = layer.MaxY - 5}
                    else
                        BlockYRanges[blockId].MinY = math.min(BlockYRanges[blockId].MinY, layer.MinY)
                        BlockYRanges[blockId].MaxY = math.max(BlockYRanges[blockId].MaxY, layer.MaxY - 5)
                    end
                end
            end
        end
    end
end


-- Helper: Get target Y for the highest priority block (for fallback horizontal mining)
local function getPriorityBlockTargetY()
    local priorityBlockName = nil
    local lowestPriority = math.huge
    for name, priority in pairs(blockPriorities) do
        if priority < lowestPriority then
            lowestPriority = priority
            priorityBlockName = name
        end
    end


    if priorityBlockName then
        local priorityBlockNameNoSpaces = priorityBlockName:gsub("%s+", "")
        local blockId = nil
        for id, name in pairs(BlockIdToName) do
            if name:gsub("%s+", "") == priorityBlockNameNoSpaces then
                blockId = id
                break
            end
        end
        if blockId and BlockYRanges[blockId] then
            local maxY = BlockYRanges[blockId].MaxY
            -- Cap target Y at 98 if block's max Y is above 98
            local targetY = maxY > 98 and 98 or maxY
            return targetY
        end
    end
    return nil
end


-- Get all blocks from controller
local function getAllBlocks()
    local blocks = {}
    for mineId, mineBlocks in pairs(MiningSiteController.Mines) do
        for blockKey, blockData in pairs(mineBlocks) do
            if blockData.Health and blockData.Health >= 0 then
                local blockName = maxHealthToBlockName[blockData.MaxHealth] or "Unknown"
                local yPos = 0
                if blockData.Visual then
                    yPos = blockData.Visual:GetPivot().Position.Y
                end
                table.insert(blocks, {
                    mineId = mineId,
                    blockKey = blockKey,
                    health = blockData.Health,
                    maxHealth = blockData.MaxHealth,
                    name = blockName,
                    position = blockData.Visual and blockData.Visual:GetPivot().Position or Vector3.new(),
                    y = yPos
                })
            end
        end
    end
    return blocks
end


-- NEW: Finds the highest-priority selected block that currently exists, at any location.
local function findHighestPriorityBlockAnywhere()
    local allBlocks = getAllBlocks()
    local validBlocks = {}
    
    -- Filter for blocks that are in the priority list
    for _, block in ipairs(allBlocks) do
        if blockPriorities[block.name] then
            table.insert(validBlocks, block)
        end
    end

    -- If any priority blocks were found, sort them and return the best one
    if #validBlocks > 0 then
        table.sort(validBlocks, function(a, b)
            local aPriority = blockPriorities[a.name]
            local bPriority = blockPriorities[b.name]
            
            -- Primary sort: by priority number (lower is better)
            if aPriority ~= bPriority then
                return aPriority < bPriority
            end
            
            -- Secondary sort: by health (lower is better)
            return a.health < b.health
        end)
        return validBlocks[1] -- Return the highest priority block
    end

    return nil -- No priority blocks found anywhere
end


-- Find blocks at target Y with highest X value (for fallback horizontal mining)
local function findBlocksAtTargetYWithHighestX(targetY)
    if not targetY then return nil end

    local allBlocks = getAllBlocks()
    local validBlocks = {}
    
    for _, block in ipairs(allBlocks) do
        local keyY = tonumber(block.blockKey:match("^%d+%-(%d+)%-%d+$"))
        local keyX = tonumber(block.blockKey:match("^(%d+)%-%d+%-%d+$"))
        if keyY and keyY == targetY then
            block.keyY = keyY
            block.keyX = keyX
            table.insert(validBlocks, block)
        end
    end

    if #validBlocks > 0 then
        -- Sort by X value (highest first), then by lowest health
        table.sort(validBlocks, function(a, b)
            if a.keyX ~= b.keyX then
                return a.keyX > b.keyX -- highest X first
            end
            return a.health < b.health
        end)
        return validBlocks[1]
    end

    return nil
end


local function findPriorityBlockEnhanced()
    -- Step 1: Search for any selected block at any height.
    local priorityBlock = findHighestPriorityBlockAnywhere()
    if priorityBlock then
        return priorityBlock -- Found one, mine it.
    end

    local targetY = getPriorityBlockTargetY()
    if not targetY then
        return nil
    end
    return findBlocksAtTargetYWithHighestX(targetY + 1)
end


local function findPriorityBlockFallback()
    local allBlocks = getAllBlocks()
    if #allBlocks == 0 then return nil end

    -- Group by type
    local blocksByType = {}
    for _, block in ipairs(allBlocks) do
        if not blocksByType[block.name] then blocksByType[block.name] = {} end
        table.insert(blocksByType[block.name], block)
    end

    -- Sort priorities
    local prioritized = {}
    for name, priority in pairs(blockPriorities) do
        table.insert(prioritized, {name = name, priority = priority})
    end
    table.sort(prioritized, function(a,b) return a.priority < b.priority end)

    for _, item in ipairs(prioritized) do
        local blkName = item.name
        if blocksByType[blkName] and #blocksByType[blkName] > 0 then
            table.sort(blocksByType[blkName], function(a,b)
                if a.health == b.health then return a.y < b.y end
                return a.health < b.health
            end)
            return blocksByType[blkName][1]
        end
    end

    -- Ultimate fallback: if no priority blocks exist, mine the lowest Y block
    table.sort(allBlocks, function(a,b)
        if a.y == b.y then return a.health < b.health end
        return a.y < b.y
    end)
    return allBlocks[1]
end


-- Check if block still exists
local function blockExists(mineId, blockKey)
    return MiningSiteController.Mines[mineId] and 
            MiningSiteController.Mines[mineId][blockKey] and 
            MiningSiteController.Mines[mineId][blockKey].Health and 
            MiningSiteController.Mines[mineId][blockKey].Health > 0
end


-- AutoMine toggle
local autoMineEnabled = false
local autoMineConnection = nil
local currentTargetBlock = nil


selectblock:AddToggle("AutoMine", {
    Title = "Auto Mine",
    Description = "Mines selected blocks at any height. If none are found, mines horizontally at the target Y-level.",
    Default = false,
    Callback = function(value)
        autoMineEnabled = value

        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        if value then
            local bv = Instance.new("BodyVelocity")
            bv.Velocity = Vector3.new(0, 0, 0)
            bv.MaxForce = Vector3.new(1e5, 1e5, 1e5)
            bv.Parent = hrp

            autoMineConnection = RunService.Heartbeat:Connect(function()
                if not autoMineEnabled then return end

                -- If no current target or current target is destroyed, find new target
                if not currentTargetBlock or not (currentTargetBlock.mineId and currentTargetBlock.blockKey and blockExists(currentTargetBlock.mineId, currentTargetBlock.blockKey)) then
                    currentTargetBlock = findPriorityBlockEnhanced()
                    
                    -- Fallback to the old system if the enhanced one fails completely
                    if not currentTargetBlock then
                        currentTargetBlock = findPriorityBlockFallback()
                    end
                end

                -- Teleport and mine the block
                if currentTargetBlock and currentTargetBlock.position and currentTargetBlock.mineId and currentTargetBlock.blockKey then
                    hrp.CFrame = CFrame.new(currentTargetBlock.position)
                    MiningSiteRemote:FireServer(currentTargetBlock.mineId, currentTargetBlock.blockKey)
                end
            end)
        else
            if autoMineConnection then
                autoMineConnection:Disconnect()
                autoMineConnection = nil
            end
            currentTargetBlock = nil

            for _, bv in ipairs(hrp:GetChildren()) do
                if bv:IsA("BodyVelocity") then bv:Destroy() end
            end
        end
    end
})


task.spawn(function()
    while true do
        local priorityBlockName = nil
        local lowestPriority = math.huge
        for name, priority in pairs(blockPriorities) do
            if priority < lowestPriority then
                lowestPriority = priority
                priorityBlockName = name
            end
        end

        if priorityBlockName then
            local priorityBlockNameNoSpaces = priorityBlockName:gsub("%s+", "")
            local blockId = nil
            for id, name in pairs(BlockIdToName) do
                if name:gsub("%s+", "") == priorityBlockNameNoSpaces then
                    blockId = id
                    break
                end
            end

            if blockId and BlockYRanges[blockId] then
                local maxY = BlockYRanges[blockId].MaxY
                local targetY = maxY > 98 and 98 or maxY
            end
        end

        task.wait(3)
    end
end)


-- Toggle for transparent blocks
local transparentBlocksEnabled = false
local transparentBlocksConnection = nil


selectblock:AddToggle("TransparentBlocks", {
    Title = "Transparent Blocks",
    Description = "Makes all blocks transparent for better visibility",
    Default = false,
    Callback = function(value)
        transparentBlocksEnabled = value

        -- Function to make blocks transparent
        local function makeBlocksTransparent()
            local blocksFolder = workspace:FindFirstChild("__BLOCKS__")
            if not blocksFolder then return end

            for _, mine in ipairs(blocksFolder:GetChildren()) do
                for _, block in ipairs(mine:GetChildren()) do
                    -- Make block and its descendants transparent
                    for _, part in ipairs(block:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.Transparency = transparentBlocksEnabled and 0.7 or 0
                        end
                    end
                end
            end
        end

        -- Apply transparency immediately
        makeBlocksTransparent()

        if value then
            -- Set up periodic updates to catch new blocks
            transparentBlocksConnection = task.spawn(function()
                while transparentBlocksEnabled do
                    makeBlocksTransparent()
                    task.wait(1)
                end
            end)
        else
            -- Stop periodic updates
            if transparentBlocksConnection then
                task.cancel(transparentBlocksConnection)
                transparentBlocksConnection = nil
            end
            -- Revert transparency
             makeBlocksTransparent()
        end
    end
})

local CleopatraSection = Tabs.Mining:AddSection("Cleopatra's Quest")

local cleopatraDifficulties = {"Easy", "Medium", "Hard"}
local selectedCleopatraDifficulty = "Hard"

CleopatraSection:AddDropdown("CleopatraDifficulty", {
    Title = "Select Quest Difficulty",
    Description = "Choose Cleopatra quest difficulty",
    Values = cleopatraDifficulties,
    Default = "Hard",
    Callback = function(value)
        selectedCleopatraDifficulty = value
    end
})

local cleopatraQuestParagraph = CleopatraSection:AddParagraph("CleopatraQuestInfo", {
    Title = "Current Cleopatra Quest",
    Content = "No quest info yet.",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

local DataController = Knit.GetController("DataController")
local QuestController = Knit.GetController("QuestController")
local Quests = require(ReplicatedStorage.Shared.Data.Core.Quests)
local QuestNPCService = ReplicatedStorage.Shared.Packages.Knit.Services.QuestNPCService

local savedBlockPriorities = {}
local function saveBlockPriorities()
    savedBlockPriorities = {}
    for k, v in pairs(blockPriorities) do
        savedBlockPriorities[k] = v
    end
end

local function restoreBlockPriorities()
    blockPriorities = {}
    for k, v in pairs(savedBlockPriorities) do
        blockPriorities[k] = v
    end
    updateBlockPriorityDisplay()
end

local function setQuestBlockPriority(blockName)
    blockPriorities = {}
    blockPriorities[blockName] = 1
    updateBlockPriorityDisplay()
end

local function getClosestCleopatraQuest()
    local trackingUID = DataController:GetValue({"cleopatra", "TrackingUID"})
    if not trackingUID then return nil end

    local questData = QuestController:getFullQuest(trackingUID)
    if not questData or not questData.Quests then return nil end

    local closestQuest = nil
    local highestProgress = -1

    for _, questUID in questData.Quests do
        local qState = QuestController:get(questUID)
        if qState and not qState.Completed then
            local progress = qState.Progress or 0
            local goal = qState.Goal or 0
            local progressRatio = goal > 0 and progress / goal or 0

            -- Get the quest title for pattern matching
            local title = ""
            if qState.Type and Quests[qState.Type] then
                title = Quests[qState.Type].GetTitle(qState, goal)
            end

            -- Skip "Mine x Blocks" quests
            if not title:match("Mine %d+ Blocks") then
                if progressRatio > highestProgress then
                    highestProgress = progressRatio
                    closestQuest = qState
                end
            end
        end
    end

    return closestQuest
end

local function printCleopatraQuest()
    local data = DataController:GetValue({"cleopatra"})
    if not data then
        cleopatraQuestParagraph:SetValue("No Cleopatra quest data found.")
        return
    end

    local difficulty = DataController:GetValue({"cleopatra", "Difficulty"})
    local trackingUID = DataController:GetValue({"cleopatra", "TrackingUID"})
    if not trackingUID then
        cleopatraQuestParagraph:SetValue("No active quest selected.")
        return
    end

    local questData = QuestController:getFullQuest(trackingUID)
    if not questData then
        cleopatraQuestParagraph:SetValue("Quest data not found.")
        return
    end

    local info = "Difficulty: " .. tostring(difficulty or "None") .. "\n"
    for _, questUID in questData.Quests do
        local qState = QuestController:get(questUID)
        local progress, goal, completed, title = 0, 0, false, tostring(questUID)
        if qState then
            progress = qState.Progress or 0
            goal = qState.Goal or 0
            completed = qState.Completed or false
            if qState.Type and Quests[qState.Type] then
                title = Quests[qState.Type].GetTitle(qState, goal)
            end
        end
        info = info .. string.format("%s: %d / %d %s\n", title, progress, goal, completed and "(Completed)" or "")

    end
    cleopatraQuestParagraph:SetValue(info)
end

local autoCompleteCleopatra = false
local autoCleopatraTask = nil


CleopatraSection:AddToggle("AutoCompleteCleopatra", {
    Title = "Auto Complete Quest",
    Description = "Automatically complete Cleopatra's quest by finding the closest to completion",
    Default = false,
    Callback = function(value)
        autoCompleteCleopatra = value

        if value then
            -- Save current block priorities
            saveBlockPriorities()

            autoCleopatraTask = task.spawn(function()
                while autoCompleteCleopatra do
                    local trackingUID = DataController:GetValue({"cleopatra", "TrackingUID"})

                    if not trackingUID then
                        -- No active quest, select one
                        QuestNPCService.RE.Comm:FireServer("cleopatra-select", selectedCleopatraDifficulty)
                        task.wait(2)
                    else
                        local questData = QuestController:getFullQuest(trackingUID)
                        local allCompleted = true

                        if questData and questData.Quests then
                            for _, questUID in questData.Quests do
                                local qState = QuestController:get(questUID)
                                if qState and not qState.Completed then
                                    allCompleted = false
                                    break
                                end
                            end
                        end

                        if allCompleted then
                            -- All quests completed, claim reward
                            QuestNPCService.RE.Comm:FireServer("cleopatra-claim")
                            task.wait(2)
                        else
                            -- Find the closest quest to completion
                            local closestQuest = getClosestCleopatraQuest()
                            if closestQuest and closestQuest.Type then
                                local questTitle = ""
                                if Quests[closestQuest.Type] then
                                    questTitle = Quests[closestQuest.Type].GetTitle(closestQuest, closestQuest.Goal or 0)
                                end

                                -- Extract block name from quest title
                                local blockName = nil
                                -- Try different patterns to extract block name
                                local patterns = {
                                    "Mine (%d+) (.+)",  -- "Mine 100 Sand"
                                    "Mine (.+)",        -- "Mine Sand"
                                    "Collect (%d+) (.+)", -- "Collect 50 Iron"
                                    "Collect (.+)"      -- "Collect Iron"
                                }

                                for _, pattern in ipairs(patterns) do
                                    local match1, match2 = questTitle:match(pattern)
                                    if match2 then
                                        blockName = match2
                                        break
                                    elseif match1 and not tonumber(match1) then
                                        blockName = match1
                                        break
                                    end
                                end


                                -- If the block name is "Blocks", change it to "Sand"
                                if blockName == "Blocks" then
                                    blockName = "Sand"
                                end

                                -- If we found a specific block name
                                if blockName and blockName ~= "" then
                                    setQuestBlockPriority(blockName)
                                else
                                    -- If no specific block name extracted, restore old priorities
                                    restoreBlockPriorities()
                                end

                                -- Wait 1 second then enable Auto Mine toggle if not already enabled
                                task.wait(1)
                                if not autoMineEnabled then
                                    -- Since we can't programmatically set the toggle, we'll just enable the functionality
                                    autoMineEnabled = true
                                    
                                    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                                    if hrp then
                                        local bv = Instance.new("BodyVelocity")
                                        bv.Velocity = Vector3.new(0, 0, 0)
                                        bv.MaxForce = Vector3.new(1e5, 1e5, 1e5)
                                        bv.Parent = hrp

                                        autoMineConnection = RunService.Heartbeat:Connect(function()
                                            if not autoMineEnabled then return end

                                            -- If no current target or current target is destroyed, find new target
                                            if not currentTargetBlock or not (currentTargetBlock.mineId and currentTargetBlock.blockKey and blockExists(currentTargetBlock.mineId, currentTargetBlock.blockKey)) then
                                                currentTargetBlock = findPriorityBlockEnhanced()
                                                
                                                -- Fallback to the old system if the enhanced one fails completely
                                                if not currentTargetBlock then
                                                    currentTargetBlock = findPriorityBlockFallback()
                                                end
                                            end

                                            -- Teleport and mine the block
                                            if currentTargetBlock and currentTargetBlock.position and currentTargetBlock.mineId and currentTargetBlock.blockKey then
                                                hrp.CFrame = CFrame.new(currentTargetBlock.position)
                                                MiningSiteRemote:FireServer(currentTargetBlock.mineId, currentTargetBlock.blockKey)
                                            end
                                        end)
                                        
                                    end
                                end
                            end
                        end
                    end

                    task.wait(2)
                end
            end)
        else
            if autoCleopatraTask then
                task.cancel(autoCleopatraTask)
                autoCleopatraTask = nil
            end
            -- Disable auto mine when turning off quest completion
            if autoMineEnabled then
                autoMineEnabled = false
                if autoMineConnection then
                    autoMineConnection:Disconnect()
                    autoMineConnection = nil
                end
                currentTargetBlock = nil
                
                local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    for _, bv in ipairs(hrp:GetChildren()) do
                        if bv:IsA("BodyVelocity") then bv:Destroy() end
                    end
                end
            end
            -- Restore original block priorities
            restoreBlockPriorities()
        end
    end
})

-- Always update quest information every 2 seconds, regardless of toggle state
task.spawn(function()
    while true do
        printCleopatraQuest()
        task.wait(2)
    end
end)

-- Hand the library over to our managers
SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes{}
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

-- Add Anti-AFK button to Settings tab
local antiafk = Tabs.Settings:AddSection("Anti AFK")

Tabs.Settings:AddButton({
    Title = "Anti AFK",
    Description = "Prevents being kicked from inactivity.",
    Callback = function()
        -- First click immediately
        clickTopRight()

        -- Add periodic clicking (every 5 minutes) to prevent AFK disconnection
        task.spawn(function()
            while true do
                task.wait(300) -- 5 minutes
                clickTopRight()
            end
        end)
    end
})

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
Window:SelectTab(1)
SaveManager:LoadAutoloadConfig()


