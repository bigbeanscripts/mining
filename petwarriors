local Library = loadstring(game:HttpGet("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()


local Window = Library:Window{
    Title = "Pet Warriors - Mining",
    SubTitle = "Script Hub",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Resize = false,
    Acrylic = true,
    Theme = "Vynixu",
    MinimizeKey = Enum.KeyCode.LeftShift
}


local Tabs = {
    Mining = Window:AddTab({ Title = "Mining", Icon = "pickaxe" }),
}


local selectblock = Tabs.Mining:AddSection("Auto Mine")


-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
local RunService = game:GetService("RunService")
local BlocksEnum = require(ReplicatedStorage.Shared.Enums.Minigames.Blocks)
local MinesData = require(ReplicatedStorage.Shared.Balancing.Shared.Minigames.Mines.Mines)


-- Wait for Knit to initialize
if not Knit.IsStarted then
    Knit.OnStart():await()
end


local MiningSiteController = Knit.GetController("MiningSiteController")
local BlocksDefinition = require(ReplicatedStorage.Shared.Balancing.Shared.Minigames.Mines.Blocks)
local MiningSiteRemote = ReplicatedStorage.Shared.Packages.Knit.Services.MiningSiteService.RE.Hit


-- Build mapping: MaxHealth -> Block Name
local maxHealthToBlockName = {}
for _, blockData in pairs(BlocksDefinition) do
    if blockData.Health and blockData.Name then
        maxHealthToBlockName[blockData.Health] = blockData.Name
    end
end


-- Build block list for dropdown
local blockNames = {}
for _, blockData in pairs(BlocksDefinition) do
    if blockData.Name ~= "Air" and blockData.Name ~= "Indestructible" then
        table.insert(blockNames, blockData.Name)
    end
end
table.sort(blockNames)


-- Block priorities
local blockPriorities = {}
local nextPriority = 1


-- Priority paragraph
local blockPriorityParagraph = selectblock:AddParagraph("MinePriority", {
    Title = "Mining Priority",
    Content = "No blocks selected",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})


local function updateBlockPriorityDisplay()
    local prioritized = {}
    for name, priority in pairs(blockPriorities) do
        table.insert(prioritized, {name = name, priority = priority})
    end
    table.sort(prioritized, function(a,b) return a.priority < b.priority end)


    if #prioritized == 0 then
        blockPriorityParagraph:SetValue("No blocks selected")
        return
    end


    local text = "Priority order:\n"
    for i, item in ipairs(prioritized) do
        text = text .. i .. ". " .. item.name .. "\n"
    end
    blockPriorityParagraph:SetValue(text)
end


-- Dropdown for block selection
selectblock:AddDropdown("BlockSelect", {
    Title = "Select Blocks to Mine",
    Description = "Blocks will be prioritized in the order you select them. First selected = highest priority.",
    Values = blockNames,
    Multi = true,
    Searchable = true,
    Default = {},
    Callback = function(value)
        local currentlySelected = {}
        for name, selected in pairs(value) do
            if selected then currentlySelected[name] = true end
        end


        -- Remove deselected blocks
        for name in pairs(blockPriorities) do
            if not currentlySelected[name] then
                blockPriorities[name] = nil
            end
        end


        -- Add newly selected blocks with incrementing priority
        for name, selected in pairs(value) do
            if selected and not blockPriorities[name] then
                blockPriorities[name] = nextPriority
                nextPriority = nextPriority + 1
            end
        end


        updateBlockPriorityDisplay()
    end
})


-- BlockId <-> Name mapping for readability
local BlockIdToName = {}
for name, id in pairs(BlocksEnum) do
    BlockIdToName[id] = name
end


-- Table to store min/max Y for each blockId
local BlockYRanges = {}
for _, areaData in pairs(MinesData) do
    if areaData.Layers then
        for _, layer in ipairs(areaData.Layers) do
            if layer.LootPlan and layer.LootPlan.Rewards then
                for blockId in pairs(layer.LootPlan.Rewards) do
                    if not BlockYRanges[blockId] then
                        BlockYRanges[blockId] = {MinY = layer.MinY, MaxY = layer.MaxY}
                    else
                        BlockYRanges[blockId].MinY = math.min(BlockYRanges[blockId].MinY, layer.MinY)
                        BlockYRanges[blockId].MaxY = math.max(BlockYRanges[blockId].MaxY, layer.MaxY)
                    end
                end
            end
        end
    end
end


-- Helper: Get target Y for the highest priority block (for fallback horizontal mining)
local function getPriorityBlockTargetY()
    local priorityBlockName = nil
    local lowestPriority = math.huge
    for name, priority in pairs(blockPriorities) do
        if priority < lowestPriority then
            lowestPriority = priority
            priorityBlockName = name
        end
    end


    if priorityBlockName then
        local priorityBlockNameNoSpaces = priorityBlockName:gsub("%s+", "")
        local blockId = nil
        for id, name in pairs(BlockIdToName) do
            if name:gsub("%s+", "") == priorityBlockNameNoSpaces then
                blockId = id
                break
            end
        end
        if blockId and BlockYRanges[blockId] then
            local maxY = BlockYRanges[blockId].MaxY
            -- Cap target Y at 98 if block's max Y is above 98
            local targetY = maxY > 98 and 98 or maxY
            return targetY
        end
    end
    return nil
end


-- Get all blocks from controller
local function getAllBlocks()
    local blocks = {}
    for mineId, mineBlocks in pairs(MiningSiteController.Mines) do
        for blockKey, blockData in pairs(mineBlocks) do
            if blockData.Health and blockData.Health >= 0 then
                local blockName = maxHealthToBlockName[blockData.MaxHealth] or "Unknown"
                local yPos = 0
                if blockData.Visual then
                    yPos = blockData.Visual:GetPivot().Position.Y
                end
                table.insert(blocks, {
                    mineId = mineId,
                    blockKey = blockKey,
                    health = blockData.Health,
                    maxHealth = blockData.MaxHealth,
                    name = blockName,
                    position = blockData.Visual and blockData.Visual:GetPivot().Position or Vector3.new(),
                    y = yPos
                })
            end
        end
    end
    return blocks
end


-- NEW: Finds the highest-priority selected block that currently exists, at any location.
local function findHighestPriorityBlockAnywhere()
    local allBlocks = getAllBlocks()
    local validBlocks = {}
    
    -- Filter for blocks that are in the priority list
    for _, block in ipairs(allBlocks) do
        if blockPriorities[block.name] then
            table.insert(validBlocks, block)
        end
    end

    -- If any priority blocks were found, sort them and return the best one
    if #validBlocks > 0 then
        table.sort(validBlocks, function(a, b)
            local aPriority = blockPriorities[a.name]
            local bPriority = blockPriorities[b.name]
            
            -- Primary sort: by priority number (lower is better)
            if aPriority ~= bPriority then
                return aPriority < bPriority
            end
            
            -- Secondary sort: by health (lower is better)
            return a.health < b.health
        end)
        return validBlocks[1] -- Return the highest priority block
    end

    return nil -- No priority blocks found anywhere
end


-- Find blocks at target Y with highest X value (for fallback horizontal mining)
local function findBlocksAtTargetYWithHighestX(targetY)
    if not targetY then return nil end

    local allBlocks = getAllBlocks()
    local validBlocks = {}
    
    for _, block in ipairs(allBlocks) do
        local keyY = tonumber(block.blockKey:match("^%d+%-(%d+)%-%d+$"))
        local keyX = tonumber(block.blockKey:match("^(%d+)%-%d+%-%d+$"))
        if keyY and keyY == targetY then
            block.keyY = keyY
            block.keyX = keyX
            table.insert(validBlocks, block)
        end
    end

    if #validBlocks > 0 then
        -- Sort by X value (highest first), then by lowest health
        table.sort(validBlocks, function(a, b)
            if a.keyX ~= b.keyX then
                return a.keyX > b.keyX -- highest X first
            end
            return a.health < b.health
        end)
        return validBlocks[1]
    end

    return nil
end

-- REWRITTEN: New auto-mine logic:
-- 1. Find and mine any selected block, anywhere in the mine.
-- 2. If no selected blocks exist, fall back to mining horizontally at the target Y level.
local function findPriorityBlockEnhanced()
    -- Step 1: Search for any selected block at any height.
    local priorityBlock = findHighestPriorityBlockAnywhere()
    if priorityBlock then
        return priorityBlock -- Found one, mine it.
    end

    -- Step 2: No selected blocks were found. Fall back to horizontal mining.
    -- Calculate the target Y based on the user's highest priority selection.
    local targetY = getPriorityBlockTargetY()
    if not targetY then
        return nil -- Cannot proceed if no blocks are selected to get a target Y.
    end

    -- Mine horizontally at the calculated Y level (plus one, as per original logic).
    return findBlocksAtTargetYWithHighestX(targetY + 1)
end


-- Find highest priority block (final fallback function if everything else fails)
local function findPriorityBlockFallback()
    local allBlocks = getAllBlocks()
    if #allBlocks == 0 then return nil end

    -- Group by type
    local blocksByType = {}
    for _, block in ipairs(allBlocks) do
        if not blocksByType[block.name] then blocksByType[block.name] = {} end
        table.insert(blocksByType[block.name], block)
    end

    -- Sort priorities
    local prioritized = {}
    for name, priority in pairs(blockPriorities) do
        table.insert(prioritized, {name = name, priority = priority})
    end
    table.sort(prioritized, function(a,b) return a.priority < b.priority end)

    for _, item in ipairs(prioritized) do
        local blkName = item.name
        if blocksByType[blkName] and #blocksByType[blkName] > 0 then
            table.sort(blocksByType[blkName], function(a,b)
                if a.health == b.health then return a.y < b.y end
                return a.health < b.health
            end)
            return blocksByType[blkName][1]
        end
    end

    -- Ultimate fallback: if no priority blocks exist, mine the lowest Y block
    table.sort(allBlocks, function(a,b)
        if a.y == b.y then return a.health < b.health end
        return a.y < b.y
    end)
    return allBlocks[1]
end


-- Check if block still exists
local function blockExists(mineId, blockKey)
    return MiningSiteController.Mines[mineId] and 
            MiningSiteController.Mines[mineId][blockKey] and 
            MiningSiteController.Mines[mineId][blockKey].Health and 
            MiningSiteController.Mines[mineId][blockKey].Health > 0
end


-- AutoMine toggle
local autoMineEnabled = false
local autoMineConnection = nil
local currentTargetBlock = nil


selectblock:AddToggle("AutoMine", {
    Title = "Auto Mine",
    Description = "Mines selected blocks at any height. If none are found, mines horizontally at the target Y-level.",
    Default = false,
    Callback = function(value)
        autoMineEnabled = value

        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        if value then
            local bv = Instance.new("BodyVelocity")
            bv.Velocity = Vector3.new(0, 0, 0)
            bv.MaxForce = Vector3.new(1e5, 1e5, 1e5)
            bv.Parent = hrp

            autoMineConnection = RunService.Heartbeat:Connect(function()
                if not autoMineEnabled then return end

                -- If no current target or current target is destroyed, find new target
                if not currentTargetBlock or not (currentTargetBlock.mineId and currentTargetBlock.blockKey and blockExists(currentTargetBlock.mineId, currentTargetBlock.blockKey)) then
                    currentTargetBlock = findPriorityBlockEnhanced()
                    
                    -- Fallback to the old system if the enhanced one fails completely
                    if not currentTargetBlock then
                        currentTargetBlock = findPriorityBlockFallback()
                    end
                end

                -- Teleport and mine the block
                if currentTargetBlock and currentTargetBlock.position and currentTargetBlock.mineId and currentTargetBlock.blockKey then
                    hrp.CFrame = CFrame.new(currentTargetBlock.position)
                    MiningSiteRemote:FireServer(currentTargetBlock.mineId, currentTargetBlock.blockKey)
                end
            end)
        else
            if autoMineConnection then
                autoMineConnection:Disconnect()
                autoMineConnection = nil
            end
            currentTargetBlock = nil

            for _, bv in ipairs(hrp:GetChildren()) do
                if bv:IsA("BodyVelocity") then bv:Destroy() end
            end
        end
    end
})


task.spawn(function()
    while true do
        local priorityBlockName = nil
        local lowestPriority = math.huge
        for name, priority in pairs(blockPriorities) do
            if priority < lowestPriority then
                lowestPriority = priority
                priorityBlockName = name
            end
        end

        if priorityBlockName then
            local priorityBlockNameNoSpaces = priorityBlockName:gsub("%s+", "")
            local blockId = nil
            for id, name in pairs(BlockIdToName) do
                if name:gsub("%s+", "") == priorityBlockNameNoSpaces then
                    blockId = id
                    break
                end
            end

            if blockId and BlockYRanges[blockId] then
                local maxY = BlockYRanges[blockId].MaxY
                local targetY = maxY > 98 and 98 or maxY
            end
        end

        task.wait(3)
    end
end)


-- Toggle for transparent blocks
local transparentBlocksEnabled = false
local transparentBlocksConnection = nil


selectblock:AddToggle("TransparentBlocks", {
    Title = "Transparent Blocks",
    Description = "Makes all blocks transparent for better visibility",
    Default = false,
    Callback = function(value)
        transparentBlocksEnabled = value

        -- Function to make blocks transparent
        local function makeBlocksTransparent()
            local blocksFolder = workspace:FindFirstChild("__BLOCKS__")
            if not blocksFolder then return end

            for _, mine in ipairs(blocksFolder:GetChildren()) do
                for _, block in ipairs(mine:GetChildren()) do
                    -- Make block and its descendants transparent
                    for _, part in ipairs(block:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.Transparency = transparentBlocksEnabled and 0.7 or 0
                        end
                    end
                end
            end
        end

        -- Apply transparency immediately
        makeBlocksTransparent()

        if value then
            -- Set up periodic updates to catch new blocks
            transparentBlocksConnection = task.spawn(function()
                while transparentBlocksEnabled do
                    makeBlocksTransparent()
                    task.wait(2)
                end
            end)
        else
            -- Stop periodic updates
            if transparentBlocksConnection then
                task.cancel(transparentBlocksConnection)
                transparentBlocksConnection = nil
            end
            -- Revert transparency
             makeBlocksTransparent()
        end
    end
})
